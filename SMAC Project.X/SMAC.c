/*
 * File:   Micro Project.c
 * Author: pmorton, SMAC
 * For Micro 1 Project
 * Uses OLED display, LCD display, A2D, Moisture Sensor, Solenoid
 * Displays temperature and moisture reading and displays it and turns on valve
 *
 * Modified Mar 2019 to use the OLED display with 1829 chip
 *
 * Created on October 18, 2023, 8:04 PM
 * Modified on April 13, 2024
 */

	//////////////////////////////////////////////////////////
//
//  SSD1306 display with 1829,  Note use of const array vs static array
//  array is 1k bytes and not enough memory to use RAM for splash screen
//  Clock : 4MHz  (Internal)
//  Target : 16F1829
//  Use I2C pins RB4 and RB6  and both I2C headers on Viva 5.4
//  Analog board uses RC2, RC3 and RB5 for inputs  POT on RB5/AN11
//  
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// Start here
//

#include <xc.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include  "i2c.h"
#include  "SSD1306.h"
#include  "i2c_LCD.h"
#include  "DHT-11.h"


// PIC16F18446 Configuration Bit Settings

// 'C' source line config statements
// CONFIG1
#pragma config FOSC = INTOSC	// Oscillator Selection (INTOSC oscillator: I/O function on CLKIN pin)
#pragma config WDTE = OFF   	// Watchdog Timer Enable (WDT disabled)
#pragma config PWRTE = OFF  	// Power-up Timer Enable (PWRT disabled)
#pragma config MCLRE = ON   	// MCLR Pin Function Select (MCLR/VPP pin function is MCLR)
#pragma config CP = OFF     	// Flash Program Memory Code Protection (Program memory code protection is disabled)
#pragma config CPD = OFF    	// Data Memory Code Protection (Data memory code protection is disabled)
#pragma config BOREN = ON   	// Brown-out Reset Enable (Brown-out Reset enabled)
#pragma config CLKOUTEN = OFF   // Clock Out Enable (CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin)
#pragma config IESO = OFF   	// Internal/External Switchover (Internal/External Switchover mode is disabled)
#pragma config FCMEN = OFF  	// Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is disabled)

// CONFIG2
#pragma config WRT = OFF    	// Flash Memory Self-Write Protection (Write protection off)
#pragma config PLLEN = OFF  	// PLL Enable (4x PLL disabled)
#pragma config STVREN = ON  	// Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
#pragma config BORV = LO    	// Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), low trip point selected.)
#pragma config LVP = ON     	// Low-Voltage Programming Enable (Low-voltage programming enabled)


#define I2C_SLAVE 0x27 //For LCD display
#define OLED_SLAVE 0x78 //Note this is in Header file already
#define BAUD 9600
#define FOSC 4000000L
#define DIVIDER ((int)(FOSC/(16UL * BAUD) -1))  //Should be 25 for 9600/4MhZ
#define NINE_BITS 0
#define SPEED 0x4
#define RX_PIN TRISC5
#define TX_PIN TRISC4
#define _XTAL_FREQ 4000000.0	/*for 4mhz*/


//void Pin_Clock_Config (void);
void pinConfig_New(void);
void A2D_Init(unsigned int Chanel);
unsigned int Get_A2D_Result(void);



//*Function Prototypes*//  
void pinConfig_New(void);  
void setup_comms(void);  
void putch(unsigned char);  
unsigned char getch(void);  
unsigned char getche(void);  
 
//*Global Vars*//  
unsigned int  Temp, FVval;  
unsigned int Pval;

/* Image generated by the tool:  GLCD Bitmap Editor, display KS0108 */
//const char Logo[1024] = { ... };

// This is the open screen says "UTSA" with road runner icon


//const  char Logo[1024] = {
//0x00, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
//0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
//0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
//0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
//0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
//0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
//0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
//0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
//0x0F, 0x0F, 0x0F, 0x0F, 0x8F, 0xCF, 0xCF, 0xCF, 0x8F, 0x8F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
//0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
//0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3E, 0xFE, 0xFC, 0xFC, 0xFC,
//0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFE, 0x3E, 0x3E, 0x3E, 0x1C, 0x00, 0x00, 0x00, 0x00,
//0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0xF0, 0xF0, 0x00, 0x10, 0x10, 0x10, 0xF0, 0xF0, 0x10, 0x10, 0x10, 0x00, 0x00, 0xF0,
//0xF0, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0x30, 0xF0, 0xC0, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3F,
//0x1F, 0xFF, 0xFF, 0x07, 0x07, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xC0, 0x80, 0x80, 0x80,
//0x80, 0xC0, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3,
//0xE3, 0xC7, 0x8E, 0xCE, 0xFC, 0x78, 0x00, 0xE0, 0xF8, 0x3F, 0x37, 0x31, 0x30, 0x31, 0x37, 0x3F,
//0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
//0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
//0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
//0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
//0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
//0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
//0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
//0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
//0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
//0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
//0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
//0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
//};


/*  ********************************************************************* */
void main(void) 
{
	unsigned char Sout[20];  //Define a buffer
	unsigned char LCD_pos, j;
	unsigned int Pot, i;


	/* Sample code to set up the A2D module */
	//Pin_Clock_Config ();  //Set up 4MHz Clk and all pins
	pinConfig_New ();
	A2D_Init(11);
	i2c_Init();   			 // Start I2C as Master 100KH
	I2C_LCD_Init(I2C_SLAVE);
	I2C_LCD_Pos(I2C_SLAVE,0x40);
	//sprintf(Sout,"Hello SMAC 	");
	//I2C_LCD_SWrite(I2C_SLAVE,Sout, 15 );
	I2C_LCD_Command(I2C_SLAVE, 0x01);   	 //Clear display

	SSD1306_Init(); //Init OLED display
	SSD1306_Fill( 0 ); //Clear display
    
	setup_comms(); //set up the USART settings defined in usart.h
	TSEN = 1;
	TSRNG = 0;
    
	FVRCON = 0xA2;
    
	//Get set up for A2D
	ADCON1 = 0xC0; //Right justify and Fosc/4 and Vss and Vdd references


	//SSD1306_Image( Logo, 1 ); //First is Image, 2nd is 0=dark bkg, 1=Light bkg
	//__delay_ms(2000);    
    // SSD1306_Fill( 0 ); //Clear display
    
	while(1)
    {
        //Pot Read it is on Chanel AN11 thus the value in the ADCON0 reg = 0x2D;
    	ADCON0 = 0x2D; //set up for the pot input channel AN11
    	__delay_ms(2); //allow cap to recharge
    	ADGO = 1; //initiate conversion on the selected channel
    	while(ADGO)continue;
    	Pval=(100*(100.00/72.00))-(((unsigned)(ADRESH<<8)+(ADRESL))*(100.00/1024.00)*(100.00/72.00));
    	//Store 10 bits into Pval, 8 + 2
      	 
    	/*Internal Temperature Read*/
        ADCON0 = 0x19; // set up for the temp input channel = 11101  
        __delay_ms(10); //Allow cap to recharge  
        ADGO = 1; // initiate conversion on the selected channel  
        while(ADGO)continue;  
        Temp = ((ADRESH<<8)+(ADRESL)); //Store 10 bits into Pval, 8 + 2
  	 
    	/*Write to Terminal + Temperature Math*/  
        printf("Temp value is: %d F | Moisture Percent: %d | RA2 is: %d \n\r", Temp, Pval, RA2);  
        __delay_ms(250); 
       
       TRISA = 0x00;
       ANSELA = 0;
       if(Pval < 20)
       {
           RA2 = 1;
       }
       else 
       {
           RA2 = 0;
       }
  	 
   	 
        //Display moisture level and temperature
        //int Pot = Get_A2D_Result();
        while(1)
        {    
            I2C_LCD_Command(I2C_SLAVE, 0x01); //Clear Display
                       
            
            if(Pval<10) //For single digit percentages
            {
                sprintf(Sout, "Fill Bottle Pls!");
                I2C_LCD_SWrite(I2C_SLAVE, Sout, 16);
                
                __delay_ms(5000.0);
            }
            
            else if(Pval<20) //For single digit percentages
            {
                sprintf(Sout, "Watering...");
                I2C_LCD_SWrite(I2C_SLAVE, Sout, 11);
                
                __delay_ms(5000.0);
            }
                
            else //For double digit percentages
            {
                sprintf(Sout, "Plant Watered!!");
                I2C_LCD_SWrite(I2C_SLAVE, Sout, 13);
                __delay_ms(5000.0);
            }
            

            sprintf(Sout,"Moisture:");
            SSD1306_Out16( 0 , 0, Sout, 0 ); //Prints "Moisture: " on Row 0
            sprintf(Sout,"%d%c", Pval, 37);
            SSD1306_Out16( 2 , 0, Sout, 0 ); //Prints the moisture % Row 2

            sprintf(Sout, "Temperature:");
            SSD1306_Out16( 4, 0, Sout, 0); //Prints "Temperature: " on Row 4
            sprintf(Sout, "%d F", Temp);
            SSD1306_Out16( 6, 0, Sout, 0); //Prints the temp in F on Row 6
            
            __delay_ms( 200 );

        /*Pot Read  it is on Chanel AN11  Thus the value in the ADCON0 reg = 0x2D */  
           ADCON0 = 0x2D; // set up for the pot input channel AN11
           __delay_ms(2); //Allow cap to recharge  
           ADGO = 1; // initiate conversion on the selected channel  
           while(ADGO)continue;  
           Pval = (100*(100.00/71.00))- (((unsigned)(ADRESH<<8)+(ADRESL))*(100.00 / 1024.00)*(100.00/71.00)); //10 bits into Pval, 8 + 2


        /*Internal Temperature Read*/
           ADCON0 = 0x75; // set up for the temp input channel = 11101  
           __delay_ms(10); //Allow cap to recharge  
           ADGO = 1; // initiate conversion on the selected channel  
           while(ADGO)continue;  
           Temp = ((ADRESH<<8)+(ADRESL)); //Store 10 bits into Pval, 8 + 2

           float Temperature, Voltage; //Temp is an unsigned int
           Temp = (((ADRESH << 8) + (ADRESL))-655);
           Voltage = (float)(Temp * 5.0)/1024;
           Temperature = (Voltage - 0.5)/0.01;

        /*Write to Terminal + Temperature Math*/  
           printf("Temp value is: %d F | Moisture Percent: %d | RA2 is: %d \n\r", Temp, Pval, RA2);  
           __delay_ms(1000);

           TRISA = 0x00;
           ANSELA = 0;
           if(Pval < 20)
           {
               RA2 = 1;
           }
           else
           {
               RA2 = 0;
           }
 
      
        }
	}
}

//void Pin_Clock_Config (){
//   OSCCON = 0x68; //  Sets HFINTOSC without PLL to 4MHz
//   LATA 	=  0x24;
//   LATB 	=  0x00;
//   LATC 	=  0x40;
//   TRISA	=  0x1B;  //5 and 2 outs
//   TRISB	=  0xF0;  //All B's inputs
//   TRISC	=  0xBF;  //Only RC6 is output
//   ANSELA   =  0x00;  //All Digital
//   ANSELB   =  0x20;  //Only RB5 set for analog
//   ANSELC   =  0x0C;  //RC3 and 2 analog rest digital
//   LATA 	=  0x24;  // Turn off the Green and Blue
//   LATB 	=  0x00;  //All 0
//   LATC 	=  0x40;
//}

void pinConfig_New(void)
{
	OSCCON = 0x68;
	TXCKSEL = 1; //both bits in APFCON0 MUST BE 1 for 1829
	RXDTSEL = 1; //Makes RC4 & 5 TX & RX for USART (Allows ICSP)
    
	TRISA = 0x1B;
	ANSELA = 0x10;
	TRISC = 0x0C;
	ANSELC = 0x0C;
	TRISB = 0xF0;
	ANSELB = 0xF0;
	INTCON = 0;
}

void setup_comms(void)
{
	RX_PIN = 1;
	TX_PIN =1;
	SPBRG = DIVIDER;
	RCSTA = (NINE_BITS | 0x90);
	TXSTA = (SPEED | NINE_BITS | 0x20);
	TXEN = 1;
	SYNC = 0;
	SPEN = 1;
	BRGH = 1;
}

void putch(unsigned char byte)  
{  
    /* output one byte */  
    while(!TXIF) /* set when register is empty */  
    continue;  
    TXREG = byte;  
}  

unsigned char getch()  
{  
    /* retrieve one byte */  
    while(!RCIF) /* set when register is not empty */  
    continue;  
    return RCREG;  
}  

unsigned char getche(void)  
{  
    unsigned char c;  
    putch(c = getch());  
    return c;  
}

void A2D_Init(unsigned int Chanel)
{
	//Make sure the pin ref by Chanel is set for analog and input
	ADCON1  = 0xC0;          	//R justify and Fosc/4
	ADCON0  = (Chanel << 2)| 1;  //Sets up for RB5 AN11
}

//unsigned int Get_A2D_Result(void){
//	int j;
//	for (j=0; j<0x02; j++) continue; //allows the sampling capacitor to charge
//    ADGO  = 1;    // initiate conversion on the selected channel
//    while(ADGO)continue;
//    return ((ADRESH<<8)+(ADRESL)) ;
//}
